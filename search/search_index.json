{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pnp SPFx Yeoman generator The composeability model of Yeoman generator is on of its core features allow you to build your own or consume and reuse already built generator. The Microsofts SharePoint Framework Yeoman generator supports this model too. The PnP SPFx Yeoman generator uses 100% of the SPFx Yeoman generator and adds functionalities on top of this framework. The extension support ranges from client-side libraries such as pnpjs and jQuery to extend the capabilities to more complex extension such as the integration of HandlebarsJS, VueJS and many more. The PnP SPFx Yeoman generator uses 100% of the Microsoft SPFx Yeoman generator but then adds functionalities on top of this framework. This extension supports additional client-side libraries such as PnPjs or jQuery to extend SPFx capabilities as well as even more complex extensions such as the integration of HandlebarsJS, VueJS, and many more. Limitation: Right now the PnP SPFx yeoman generator supports only the initial setup of new projects. To add additional web parts and extensions, please continue to use the Microsoft SPFx generator. In the future, this generator will be used to add elements to existing projects. Based on Generator Base Generator @microsoft/generator-sharepoint 1.5.1 Client-side extensions and Add-ons Library Version Documentation jQuery 2.x, 3.x @pnp/pnpjs 1.4. Framework Extensions Framework Version Documentation Handlebars 4.0.0 Get started VueJS TBD Get started Angular Elements planned Get started Installation The generator needs to be installed globally depending on the package manager you use. Using NPM: npm install -g @pnp/generator-spfx Using Yarn: yarn install global @pnp/generator-spfx Using pnpm: pnpm install global-pnpmfile @pnp/generator-spfx Start a new project To start a new project execute the following command: yo @pnp/spfx This will start the PnP SPFx Yeoman generator for a new project that gives you all the options to choose from. Command line options The following options provide a complete list of available switches. Usage: yo @pnp/spfx [ options ] Options: -h, --help # Print the generator s options and usage --skip-cache # Do not remember prompt answers - Default: false --skip-install # Do not automatically install dependencies - Default: false --force-install # Fail on install dependencies error - Default: false --component-description # Web part description --component-name # Web part name --component-type # The type of component: - webpart - extension --enviroment # The target environment for the solution: - onprem or spo . --extension-type # The type of extension: - ApplicationCustomizer , - FieldCustomizer - ListViewCommandSet -pm, --package-manager # Let you choose the package manager: - npm - yarn - pnpm --plusbeta # Use the beta packages --skip-feature-deployment # If specified, allow the tenant admin the choice of being able to deploy the components to all sites immediately without running any feature deployment or adding apps in sites --solution-name # Solution name, as well as folder name Further information General project setup and folders Known Issues","title":"Home"},{"location":"#pnp-spfx-yeoman-generator","text":"The composeability model of Yeoman generator is on of its core features allow you to build your own or consume and reuse already built generator. The Microsofts SharePoint Framework Yeoman generator supports this model too. The PnP SPFx Yeoman generator uses 100% of the SPFx Yeoman generator and adds functionalities on top of this framework. The extension support ranges from client-side libraries such as pnpjs and jQuery to extend the capabilities to more complex extension such as the integration of HandlebarsJS, VueJS and many more. The PnP SPFx Yeoman generator uses 100% of the Microsoft SPFx Yeoman generator but then adds functionalities on top of this framework. This extension supports additional client-side libraries such as PnPjs or jQuery to extend SPFx capabilities as well as even more complex extensions such as the integration of HandlebarsJS, VueJS, and many more. Limitation: Right now the PnP SPFx yeoman generator supports only the initial setup of new projects. To add additional web parts and extensions, please continue to use the Microsoft SPFx generator. In the future, this generator will be used to add elements to existing projects.","title":"Pnp SPFx Yeoman generator"},{"location":"#based-on-generator","text":"Base Generator @microsoft/generator-sharepoint 1.5.1","title":"Based on Generator"},{"location":"#client-side-extensions-and-add-ons","text":"Library Version Documentation jQuery 2.x, 3.x @pnp/pnpjs 1.4.","title":"Client-side extensions and Add-ons"},{"location":"#framework-extensions","text":"Framework Version Documentation Handlebars 4.0.0 Get started VueJS TBD Get started Angular Elements planned Get started","title":"Framework Extensions"},{"location":"#installation","text":"The generator needs to be installed globally depending on the package manager you use. Using NPM: npm install -g @pnp/generator-spfx Using Yarn: yarn install global @pnp/generator-spfx Using pnpm: pnpm install global-pnpmfile @pnp/generator-spfx","title":"Installation"},{"location":"#start-a-new-project","text":"To start a new project execute the following command: yo @pnp/spfx This will start the PnP SPFx Yeoman generator for a new project that gives you all the options to choose from.","title":"Start a new project"},{"location":"#command-line-options","text":"The following options provide a complete list of available switches. Usage: yo @pnp/spfx [ options ] Options: -h, --help # Print the generator s options and usage --skip-cache # Do not remember prompt answers - Default: false --skip-install # Do not automatically install dependencies - Default: false --force-install # Fail on install dependencies error - Default: false --component-description # Web part description --component-name # Web part name --component-type # The type of component: - webpart - extension --enviroment # The target environment for the solution: - onprem or spo . --extension-type # The type of extension: - ApplicationCustomizer , - FieldCustomizer - ListViewCommandSet -pm, --package-manager # Let you choose the package manager: - npm - yarn - pnpm --plusbeta # Use the beta packages --skip-feature-deployment # If specified, allow the tenant admin the choice of being able to deploy the components to all sites immediately without running any feature deployment or adding apps in sites --solution-name # Solution name, as well as folder name","title":"Command line options"},{"location":"#further-information","text":"General project setup and folders Known Issues","title":"Further information"},{"location":"about/","text":"About @pnp/generator-spfx","title":"About"},{"location":"about/#about-pnpgenerator-spfx","text":"","title":"About @pnp/generator-spfx"},{"location":"contribution-guidelines/","text":"Contribution Guidelines There are not many contribution guidelines but here are some helpers and how we build the Yeoman generator. Basic technologies to know Write your own Yeoman generator - This provide you some basic insights how to write a custom Yeoman generator Mocha getting started - To test the Yeoman generator work properly a testing framework named Mocha is used Embedded JavaScript templating - Is the core engine used in Yeoman do deploy template files and dynamically embed custom settings in the files getting deployed. Places to look for help The JavaScript a Yeoman generator uses is based on NodeJS and many things are treated differently than the JavaScript that exists in browsers. Yeoman API Documentation - Beside the getting started guide there is an official documentation availabe that cover the complete Yeoman API. NodeJS documentation - In general a Yeoman generator is written is JavaScript but it is based on NodeJS the developmeent patterns are slightly different. In some cases it might be handy to consult the NodeJS documentation. Frequently asked questions Why can't I use TypeScript? TypeScript requires compilation to JavaScript. The result is in more complexity and less support from the Yeoman community. To keep it plain and simple only NodeJS JavaScript will be used. Most concepts such as classes can be used in NodeJS anyway. Do I need to install @microsoft/generator-sharepoint? No - The PnP SPFx generator has a dependency on a specific version on @microsoft/generator-sharepoint. This version will be automatically installed in the generator source. Can I have a different versions of @microsoft/generator-sharepoint installed? Yes you can for example have version 1.4.1 installed manually on your machine. When you run yo @microsoft/sharepoint this version will be used. However in case you like to run yo @pnp/spfx the version the community generator was built on will be used. For example version 1.6 instead.","title":"Contribution Guidelines"},{"location":"contribution-guidelines/#contribution-guidelines","text":"There are not many contribution guidelines but here are some helpers and how we build the Yeoman generator.","title":"Contribution Guidelines"},{"location":"contribution-guidelines/#basic-technologies-to-know","text":"Write your own Yeoman generator - This provide you some basic insights how to write a custom Yeoman generator Mocha getting started - To test the Yeoman generator work properly a testing framework named Mocha is used Embedded JavaScript templating - Is the core engine used in Yeoman do deploy template files and dynamically embed custom settings in the files getting deployed.","title":"Basic technologies to know"},{"location":"contribution-guidelines/#places-to-look-for-help","text":"The JavaScript a Yeoman generator uses is based on NodeJS and many things are treated differently than the JavaScript that exists in browsers. Yeoman API Documentation - Beside the getting started guide there is an official documentation availabe that cover the complete Yeoman API. NodeJS documentation - In general a Yeoman generator is written is JavaScript but it is based on NodeJS the developmeent patterns are slightly different. In some cases it might be handy to consult the NodeJS documentation.","title":"Places to look for help"},{"location":"contribution-guidelines/#frequently-asked-questions","text":"","title":"Frequently asked questions"},{"location":"contribution-guidelines/#why-cant-i-use-typescript","text":"TypeScript requires compilation to JavaScript. The result is in more complexity and less support from the Yeoman community. To keep it plain and simple only NodeJS JavaScript will be used. Most concepts such as classes can be used in NodeJS anyway.","title":"Why can't I use TypeScript?"},{"location":"contribution-guidelines/#do-i-need-to-install-microsoftgenerator-sharepoint","text":"No - The PnP SPFx generator has a dependency on a specific version on @microsoft/generator-sharepoint. This version will be automatically installed in the generator source.","title":"Do I need to install @microsoft/generator-sharepoint?"},{"location":"contribution-guidelines/#can-i-have-a-different-versions-of-microsoftgenerator-sharepoint-installed","text":"Yes you can for example have version 1.4.1 installed manually on your machine. When you run yo @microsoft/sharepoint this version will be used. However in case you like to run yo @pnp/spfx the version the community generator was built on will be used. For example version 1.6 instead.","title":"Can I have a different versions of @microsoft/generator-sharepoint installed?"},{"location":"known-issues/","text":"Known Issues None so far. If you find one please submit to issue to our GitHub Repository .","title":"Known Issues"},{"location":"known-issues/#known-issues","text":"None so far. If you find one please submit to issue to our GitHub Repository .","title":"Known Issues"},{"location":"compose/","text":"Compose custom SPFx generators PnP SPFx Generator - Development Before you start development of custom yeoman generators please be sure to read Writing your own Yeoman Generator . The following chapters explain the overall setup and considerations. Project Setup The following directory listing gives you an overview of the main directories in the generator. \u251c\u2500\u2500 app -- Main Generator \u251c\u2500\u2500 docs -- Documentation \u251c\u2500\u2500 generators -- custom generators \u2502 \u251c\u2500\u2500 addons -- Addon Generator reserved for client libraries only \u2502 \u251c\u2500\u2500 handlebars -- PnP Handlebars generator \u251c\u2500\u2500 lib -- General purpose libraries \u251c\u2500\u2500 test -- Mocha Unit Test \u251c\u2500\u2500 tools \u2502 \u251c\u2500\u2500 generator-template -- Template yeoman generator Get started writing a new generator To get started implementing and adding a new generator, copy the template folder in the generators folder and rename it to a meaningful name matching your framework. In the folder you will find the following files: index.js - main sub generator file promptconfig.js - special prompt config related to sub generator template/addonConfig.json - This file contains all NPM Packages that need to be installed User prompt for sub generator In case the generator need some additional information from the user, questions can be configured in the file promptconfig.js . The content of this file follows the default Yeoman generator user prompting described in the article Interacting with the User . The library Yeoman uses is inquer.js . use strict // These are just sample selection of options const options = [{ name : Option A , value : option-a }, { name : Option B , value : option-b } ]; const configOptions = [ // Sample content of questions { type : list , message : Please add your options in here , name : youroptions , choices : options } // , addon ] const promptConfig = { config : configOptions } module . exports = promptConfig ; This sample exports the configuration as a module and can be integrated in the main Yeoman generator to consolidate the user prompts in the main generator. Generator implementation - index.js All actions required for a new custom generator need to be implemented in the index.js file. The default template currently lists all possible methods in the right call order provided by the default Yeoman generator. // Base Yeoman generator const Generator = require ( yeoman-generator ); // prompt configuration const prompts = require ( ./promptConfig ); module . exports = class extends Generator { constructor ( args , opts ) { super ( args , opts ); // configuration of user prompt } // Initialisation geenerator initializing () { } // Prompt for user input for Custom Generator prompting () { } // adds additonal editor support in this case CSS Comb configuring () { // Currently not supported - Don t use this } // adds additonal editor support in this case CSS Comb writing () { // Currently not supported - Don t use this } // adds additonal editor support in this case CSS Comb install () { /** * Place your custom deployment code in here */ } // Run installer normally time to say goodbye // If yarn is installed yarn will be used end () { } } The call order of a Yeoman generator is defined in the following steps: constructor() initializing() prompting() configuring() writing() install() end() Because of the dependency on the Microsoft Yeoman Generator, the actions need to be delayed to the next step. After the SPFx generator has written the files to the file system through its writing() method, the custom generator is able to update the configuration with additional information. Instead of adding the code of the custom generator to the writing() method, the code has to be added to the install() method. In the case of the Handlebars generator, the following functions get called in the install() method: install () { // deploy additional files to the project directory this . _deployFiles (); // add external to the configuration this . _addExternals (); // add all package depenedencies configured in addonConfig.json. this . _addPackageDependencies (); // inject custom tasks to gulpfile this . _injectToGulpFile (); // finally run install util . runInstall ( this ); } This is required because all additional tasks have to be performed on top of the assets deployed by the SPFx default assets. Further reading: How to implement prompting","title":"General"},{"location":"compose/#compose-custom-spfx-generators","text":"","title":"Compose custom SPFx generators"},{"location":"compose/#pnp-spfx-generator-development","text":"Before you start development of custom yeoman generators please be sure to read Writing your own Yeoman Generator . The following chapters explain the overall setup and considerations.","title":"PnP SPFx Generator - Development"},{"location":"compose/#project-setup","text":"The following directory listing gives you an overview of the main directories in the generator. \u251c\u2500\u2500 app -- Main Generator \u251c\u2500\u2500 docs -- Documentation \u251c\u2500\u2500 generators -- custom generators \u2502 \u251c\u2500\u2500 addons -- Addon Generator reserved for client libraries only \u2502 \u251c\u2500\u2500 handlebars -- PnP Handlebars generator \u251c\u2500\u2500 lib -- General purpose libraries \u251c\u2500\u2500 test -- Mocha Unit Test \u251c\u2500\u2500 tools \u2502 \u251c\u2500\u2500 generator-template -- Template yeoman generator","title":"Project Setup"},{"location":"compose/#get-started-writing-a-new-generator","text":"To get started implementing and adding a new generator, copy the template folder in the generators folder and rename it to a meaningful name matching your framework. In the folder you will find the following files: index.js - main sub generator file promptconfig.js - special prompt config related to sub generator template/addonConfig.json - This file contains all NPM Packages that need to be installed","title":"Get started writing a new generator"},{"location":"compose/#user-prompt-for-sub-generator","text":"In case the generator need some additional information from the user, questions can be configured in the file promptconfig.js . The content of this file follows the default Yeoman generator user prompting described in the article Interacting with the User . The library Yeoman uses is inquer.js . use strict // These are just sample selection of options const options = [{ name : Option A , value : option-a }, { name : Option B , value : option-b } ]; const configOptions = [ // Sample content of questions { type : list , message : Please add your options in here , name : youroptions , choices : options } // , addon ] const promptConfig = { config : configOptions } module . exports = promptConfig ; This sample exports the configuration as a module and can be integrated in the main Yeoman generator to consolidate the user prompts in the main generator.","title":"User prompt for sub generator"},{"location":"compose/#generator-implementation-indexjs","text":"All actions required for a new custom generator need to be implemented in the index.js file. The default template currently lists all possible methods in the right call order provided by the default Yeoman generator. // Base Yeoman generator const Generator = require ( yeoman-generator ); // prompt configuration const prompts = require ( ./promptConfig ); module . exports = class extends Generator { constructor ( args , opts ) { super ( args , opts ); // configuration of user prompt } // Initialisation geenerator initializing () { } // Prompt for user input for Custom Generator prompting () { } // adds additonal editor support in this case CSS Comb configuring () { // Currently not supported - Don t use this } // adds additonal editor support in this case CSS Comb writing () { // Currently not supported - Don t use this } // adds additonal editor support in this case CSS Comb install () { /** * Place your custom deployment code in here */ } // Run installer normally time to say goodbye // If yarn is installed yarn will be used end () { } } The call order of a Yeoman generator is defined in the following steps: constructor() initializing() prompting() configuring() writing() install() end() Because of the dependency on the Microsoft Yeoman Generator, the actions need to be delayed to the next step. After the SPFx generator has written the files to the file system through its writing() method, the custom generator is able to update the configuration with additional information. Instead of adding the code of the custom generator to the writing() method, the code has to be added to the install() method. In the case of the Handlebars generator, the following functions get called in the install() method: install () { // deploy additional files to the project directory this . _deployFiles (); // add external to the configuration this . _addExternals (); // add all package depenedencies configured in addonConfig.json. this . _addPackageDependencies (); // inject custom tasks to gulpfile this . _injectToGulpFile (); // finally run install util . runInstall ( this ); } This is required because all additional tasks have to be performed on top of the assets deployed by the SPFx default assets. Further reading: How to implement prompting","title":"Generator implementation - index.js"},{"location":"compose/add-addons/","text":"Step-by-Step Guide for custom addons Applies to: generators/addons In case to integrate custom client side development dependencies there is no requirement to write an own generator this can be included directly in the addon generator. Add npm dependencies The dependency configuration of additional addons is located in generators/addons/templates and is named addonConfig.json. In this JSON file you can include additional configuration for various NPM packages. This also the { jquery@2 : { dependencies : { jquery : ^2.2.4 , @types/jquery : ^2.0.49 } }, jquery@3 : { dependencies : { jquery : ^3.0.0 , @types/jquery : ^3.0.0 } }, pnpjs : { dependencies : { @pnp/pnpjs : ^1.1.1 } } } To add a custom library add a new property in the form of: yourcustomlibrary@2 : { // custom library name @ major version label dependencies : { // dependencies or devDependencies firstdependency : ^1.0.0 , // library named first dependecy, @types/firstdependency : ^1.0.0 , // types for first dependecy // .. any additional library } } The updated addonConfiguration.json file then might look like this: { jquery@2 : { dependencies : { jquery : ^2.2.4 , @types/jquery : ^2.0.49 } }, jquery@3 : { dependencies : { jquery : ^3.0.0 , @types/jquery : ^3.0.0 } }, pnpjs : { dependencies : { @pnp/pnpjs : ^1.1.1 } }, yourcustomlibrary@2 : { dependencies : { firstdependency : ^1.0.0 , @types/firstdependency : ^1.0.0 } } } DO NOT use comments in JSON files - The files become invalid Integrate new library in prompting To ask the user to include this new library open the promptConfig.js file in the addon generator. In the config optiosn add a reference to the new library. ... const configOptions = [ // Library selection { type : checkbox , message : Which libraries to include , name : jsLibrary , choices : [{ name : jQuery , value : jquery }, { name : pnpjs , value : @pnp/pnpjs }, // New reference { name : New awesome library to include , value : yourcustomlibrary@2 } ] }, // jQuery version selection { type : list , message : ` ${ chalk . bold . yellow ( jQuery: ) } Please choose a version:` , name : jQueryVersion , choices : jqueryOptions , when : answers = answers . jsLibrary . indexOf ( jquery ) !== - 1 } ] module . exports = configOptions ; The name of the new reference can set to any descriptive test and the value must match the property name used in the addonConfig.json . The selection of this dialog gets picked up automatically during the provisioning process and will be added to the package.json option. Inject dependencies in custom generator It is possible to use the same mechanism in custom generators too. The sub generator for Handlebars for example make use of the same mechanism. A config file for all required npm packages to include can be found in this generator too. { handlebars : { dependencies : { handlebars : ^4.0.6 }, devDependencies : { handlebars-template-loader : ^1.0.0 , @types/handlebars : ^4.0.39 } } } This addonConfig.json in the handlebar generator contains all required dependencies. Those npm packages that are required during runtime and those required during development. To inject those dependecies to the package.json call the following method in your generator code. _addPackageDependencies () { if ( fs . existsSync ( this . destinationPath ( package.json ))) { // request the default package file let config ; try { config = JSON . parse ( fs . readFileSync ( this . destinationPath ( package.json ) )); } catch ( error ) { throw error ; } // request current addon configuration let addonConfig ; try { addonConfig = JSON . parse ( fs . readFileSync ( this . templatePath ( addonConfig.json ) ) ) } catch ( err ) { throw err ; } // select the requested libraried let requestedLibraries = [ handlebars ]; // declare new package config file let newPkgConfig ; try { newPkgConfig = util . mergeAddons ( addonConfig , requestedLibraries , config ); } catch ( error ) { throw error } // if content could be added to the new package.json write it if ( newPkgConfig !== undefined newPkgConfig !== null ) { fs . writeFileSync ( this . destinationPath ( package.json ), JSON . stringify ( newPkgConfig , null , 2 ) ); } else { throw Updated package.json file is invalid. ; } } } On the requested library pass in an array of identifier stored in your addon configuration. In case of the handlebar generator this is just 'handlebars'. let requestedLibraries = [ handlebars ]; You can have multiple identifiers in this array. Remark It is possible to inject additional dependencies by calling npm install from the generator directly. In case of multiple runs there maybe delayes and conflicts for the injection and is even a slower than adding it directly in the package.json files.","title":"Addon generator"},{"location":"compose/add-addons/#step-by-step-guide-for-custom-addons","text":"Applies to: generators/addons In case to integrate custom client side development dependencies there is no requirement to write an own generator this can be included directly in the addon generator.","title":"Step-by-Step Guide for custom addons"},{"location":"compose/add-addons/#add-npm-dependencies","text":"The dependency configuration of additional addons is located in generators/addons/templates and is named addonConfig.json. In this JSON file you can include additional configuration for various NPM packages. This also the { jquery@2 : { dependencies : { jquery : ^2.2.4 , @types/jquery : ^2.0.49 } }, jquery@3 : { dependencies : { jquery : ^3.0.0 , @types/jquery : ^3.0.0 } }, pnpjs : { dependencies : { @pnp/pnpjs : ^1.1.1 } } } To add a custom library add a new property in the form of: yourcustomlibrary@2 : { // custom library name @ major version label dependencies : { // dependencies or devDependencies firstdependency : ^1.0.0 , // library named first dependecy, @types/firstdependency : ^1.0.0 , // types for first dependecy // .. any additional library } } The updated addonConfiguration.json file then might look like this: { jquery@2 : { dependencies : { jquery : ^2.2.4 , @types/jquery : ^2.0.49 } }, jquery@3 : { dependencies : { jquery : ^3.0.0 , @types/jquery : ^3.0.0 } }, pnpjs : { dependencies : { @pnp/pnpjs : ^1.1.1 } }, yourcustomlibrary@2 : { dependencies : { firstdependency : ^1.0.0 , @types/firstdependency : ^1.0.0 } } } DO NOT use comments in JSON files - The files become invalid","title":"Add npm dependencies"},{"location":"compose/add-addons/#integrate-new-library-in-prompting","text":"To ask the user to include this new library open the promptConfig.js file in the addon generator. In the config optiosn add a reference to the new library. ... const configOptions = [ // Library selection { type : checkbox , message : Which libraries to include , name : jsLibrary , choices : [{ name : jQuery , value : jquery }, { name : pnpjs , value : @pnp/pnpjs }, // New reference { name : New awesome library to include , value : yourcustomlibrary@2 } ] }, // jQuery version selection { type : list , message : ` ${ chalk . bold . yellow ( jQuery: ) } Please choose a version:` , name : jQueryVersion , choices : jqueryOptions , when : answers = answers . jsLibrary . indexOf ( jquery ) !== - 1 } ] module . exports = configOptions ; The name of the new reference can set to any descriptive test and the value must match the property name used in the addonConfig.json . The selection of this dialog gets picked up automatically during the provisioning process and will be added to the package.json option.","title":"Integrate new library in prompting"},{"location":"compose/add-addons/#inject-dependencies-in-custom-generator","text":"It is possible to use the same mechanism in custom generators too. The sub generator for Handlebars for example make use of the same mechanism. A config file for all required npm packages to include can be found in this generator too. { handlebars : { dependencies : { handlebars : ^4.0.6 }, devDependencies : { handlebars-template-loader : ^1.0.0 , @types/handlebars : ^4.0.39 } } } This addonConfig.json in the handlebar generator contains all required dependencies. Those npm packages that are required during runtime and those required during development. To inject those dependecies to the package.json call the following method in your generator code. _addPackageDependencies () { if ( fs . existsSync ( this . destinationPath ( package.json ))) { // request the default package file let config ; try { config = JSON . parse ( fs . readFileSync ( this . destinationPath ( package.json ) )); } catch ( error ) { throw error ; } // request current addon configuration let addonConfig ; try { addonConfig = JSON . parse ( fs . readFileSync ( this . templatePath ( addonConfig.json ) ) ) } catch ( err ) { throw err ; } // select the requested libraried let requestedLibraries = [ handlebars ]; // declare new package config file let newPkgConfig ; try { newPkgConfig = util . mergeAddons ( addonConfig , requestedLibraries , config ); } catch ( error ) { throw error } // if content could be added to the new package.json write it if ( newPkgConfig !== undefined newPkgConfig !== null ) { fs . writeFileSync ( this . destinationPath ( package.json ), JSON . stringify ( newPkgConfig , null , 2 ) ); } else { throw Updated package.json file is invalid. ; } } } On the requested library pass in an array of identifier stored in your addon configuration. In case of the handlebar generator this is just 'handlebars'. let requestedLibraries = [ handlebars ]; You can have multiple identifiers in this array.","title":"Inject dependencies in custom generator"},{"location":"compose/add-addons/#remark","text":"It is possible to inject additional dependencies by calling npm install from the generator directly. In case of multiple runs there maybe delayes and conflicts for the injection and is even a slower than adding it directly in the package.json files.","title":"Remark"},{"location":"compose/add-generator/","text":"Step-by-Step Custom generator This sample provides a ste","title":"Step-by-Step Custom generator"},{"location":"compose/add-generator/#step-by-step-custom-generator","text":"This sample provides a ste","title":"Step-by-Step Custom generator"},{"location":"compose/prompting/","text":"How to implement prompting Yeoman generator uses a library named inquirejs for the prompt configuration. To read more on the general prompting behaviour checkout interacting with user in the yeomman documentation. To support multiple Yeoman generators with different prompting configurations a special method was implemented in the core generators such as the addon generator. generators/addons \u251c\u2500\u2500 index.js \u251c\u2500\u2500 promptConfig.js # - this the configuration file for the prompts \u2514\u2500\u2500 templates \u2514\u2500\u2500 addonConfig.json All prompts required by the generator are included in the prompt config file directly inside the Yeoman generator. const chalk = require ( chalk ); const jqueryOptions = [{ name : 3.x.x (recommended) , value : 3 }, { name : 2.x.x , value : 2 } ] const configOptions = [ // Library selection { type : checkbox , message : Which libraries to include , name : jsLibrary , choices : [{ name : jQuery , value : jquery }, { name : pnpjs , value : @pnp/pnpjs }] }, // jQuery version selection { type : list , message : ` ${ chalk . bold . yellow ( jQuery: ) } Please choose a version:` , name : jQueryVersion , choices : jqueryOptions , when : answers = answers . jsLibrary . indexOf ( jquery ) !== - 1 } ] module . exports = configOptions ; This example defineds the questionary for jQuery and PnP and will be exported as a module in node. This is required because all configuration options will be then collected together in the main generator and is located at the /app folder. Inside this folder is another promptConfig located and the particular configuration of the addon generator prompting gets imported. // Add configuration of Addon generator const addon = require ( ../generators/addons/promptConfig ); configOptions = configOptions . concat ( addon ); const promptConfig = { config : configOptions } module . exports = promptConfig ; This code imports the module of the addon configuraton and adds the settings to the default generator prompting. This config file will again be exported as a module and gets used in the main generator code. prompting () { /* DO NOT ENTER CODE HERE */ this . prompt ( prompting . config ) . then ( answers = { // Choose appro this . options . SpfxOptions [ framework ] = this . _evalSPFxGenerator ( answers . framework ); this . options . pnpFramework = answers . framework ; this . options . libraries = this . _evalAddons ( answers ); this . options . SPFxFramework = answers . framework ; this . _configGenerators ( this . options ); }); } So this makes sure that all prompt configurations can be managed centralised even the ones specific to additional generators. Info In case you custom generator has a special promting configuration please add a remark in your PR","title":"Prompting"},{"location":"compose/prompting/#how-to-implement-prompting","text":"Yeoman generator uses a library named inquirejs for the prompt configuration. To read more on the general prompting behaviour checkout interacting with user in the yeomman documentation. To support multiple Yeoman generators with different prompting configurations a special method was implemented in the core generators such as the addon generator. generators/addons \u251c\u2500\u2500 index.js \u251c\u2500\u2500 promptConfig.js # - this the configuration file for the prompts \u2514\u2500\u2500 templates \u2514\u2500\u2500 addonConfig.json All prompts required by the generator are included in the prompt config file directly inside the Yeoman generator. const chalk = require ( chalk ); const jqueryOptions = [{ name : 3.x.x (recommended) , value : 3 }, { name : 2.x.x , value : 2 } ] const configOptions = [ // Library selection { type : checkbox , message : Which libraries to include , name : jsLibrary , choices : [{ name : jQuery , value : jquery }, { name : pnpjs , value : @pnp/pnpjs }] }, // jQuery version selection { type : list , message : ` ${ chalk . bold . yellow ( jQuery: ) } Please choose a version:` , name : jQueryVersion , choices : jqueryOptions , when : answers = answers . jsLibrary . indexOf ( jquery ) !== - 1 } ] module . exports = configOptions ; This example defineds the questionary for jQuery and PnP and will be exported as a module in node. This is required because all configuration options will be then collected together in the main generator and is located at the /app folder. Inside this folder is another promptConfig located and the particular configuration of the addon generator prompting gets imported. // Add configuration of Addon generator const addon = require ( ../generators/addons/promptConfig ); configOptions = configOptions . concat ( addon ); const promptConfig = { config : configOptions } module . exports = promptConfig ; This code imports the module of the addon configuraton and adds the settings to the default generator prompting. This config file will again be exported as a module and gets used in the main generator code. prompting () { /* DO NOT ENTER CODE HERE */ this . prompt ( prompting . config ) . then ( answers = { // Choose appro this . options . SpfxOptions [ framework ] = this . _evalSPFxGenerator ( answers . framework ); this . options . pnpFramework = answers . framework ; this . options . libraries = this . _evalAddons ( answers ); this . options . SPFxFramework = answers . framework ; this . _configGenerators ( this . options ); }); } So this makes sure that all prompt configurations can be managed centralised even the ones specific to additional generators. Info In case you custom generator has a special promting configuration please add a remark in your PR","title":"How to implement prompting"},{"location":"how-tos/","text":"How-Tos This section contains all the important information about how to work with the projects generated by this Yeoman Generator.","title":"How-Tos"},{"location":"how-tos/#how-tos","text":"This section contains all the important information about how to work with the projects generated by this Yeoman Generator.","title":"How-Tos"},{"location":"how-tos/handlebars/","text":"","title":"Handlebars"},{"location":"how-tos/jquery/","text":"How to use jQuery","title":"How to use jQuery"},{"location":"how-tos/jquery/#how-to-use-jquery","text":"","title":"How to use jQuery"},{"location":"recipes/","text":"Recipies for Development In this section you will find useful code snippets and explanations. Yeoman Run install SPFx related Inject custom gulp configuration and tasks Deploy Web Part Content, Extensions and Customizer","title":"Recipies for Development"},{"location":"recipes/#recipies-for-development","text":"In this section you will find useful code snippets and explanations.","title":"Recipies for Development"},{"location":"recipes/#yeoman","text":"Run install","title":"Yeoman"},{"location":"recipes/#spfx-related","text":"Inject custom gulp configuration and tasks Deploy Web Part Content, Extensions and Customizer","title":"SPFx related"},{"location":"recipes/deploy-custom-code/","text":"Update provisioned artifacts for web parts, extensions and customizer with generator It is possible to inject code such as references directly web parts and extensions. Right now this is only supported for SharePoint Online projects and not for on-premises focused. The tools folder provide you templates to inject code directly in the web part, application customizer, command set, field customizer. tools/spfx \u251c\u2500\u2500 applicationcustomizer-spo \u2502 \u2514\u2500\u2500 { componentClassName } .ts \u251c\u2500\u2500 commandset-spo \u2502 \u2514\u2500\u2500 { componentClassName } .ts \u251c\u2500\u2500 fieldcustomizer-spo \u2502 \u251c\u2500\u2500 { componentClassName } .module.scss \u2502 \u2514\u2500\u2500 { componentClassName } .ts \u2514\u2500\u2500 webparts-spo \u251c\u2500\u2500 { componentClassName } .module.scss \u2514\u2500\u2500 { componentClassName } .ts These files will be maintained and updated with every new mayor release of the SharePoint Framework main generator. Copy these template files to your generator Copy the files located in the template folder to your custom generator in the template path. The overall setup of the generator should match the following pattern. generators/your-generator/ \u251c\u2500\u2500 index.js \u2514\u2500\u2500 templates \u251c\u2500\u2500 addonConfig.json \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 copy-static-assets.json \u251c\u2500\u2500 gulpfile.js \u2514\u2500\u2500 spfx \u251c\u2500\u2500 applicationcustomizer-spo \u2502 \u2514\u2500\u2500 { componentClassName } .ts \u251c\u2500\u2500 fieldcustomizer-spo \u2502 \u251c\u2500\u2500 { componentClassName } .module.scss \u2502 \u2514\u2500\u2500 { componentClassName } .ts \u251c\u2500\u2500 listviewcommandset-spo \u2502 \u2514\u2500\u2500 { componentClassName } .ts \u2514\u2500\u2500 webpart-spo \u251c\u2500\u2500 { componentClassName } .module.scss \u2514\u2500\u2500 { componentClassName } .ts Now modify the files to match your requirements. In case of the HandlebarsJS generator the following line of code were added at the import statements of for example an web part. import { Version } from @microsoft/sp-core-library ; import { BaseClientSideWebPart , IPropertyPaneConfiguration , PropertyPaneTextField } from @microsoft/sp-webpart-base ; import { escape } from @microsoft/sp-lodash-subset ; import styles from ./ %= componentClassName % .module.scss ; import * as strings from %= componentStrings % ; import * as Handlebars from handlebars ; export interface I %= componentClassName % Props { description : string ; } export default class %= componentClassName % extends BaseClientSideWebPart I %= componentClassName % Props { ... The only line of code in this example that were added is the following line: import * as Handlebars from handlebars ; This make sure that after the provisioning of a web part coding can start immediatly. Deploy custom code in generator The files located in the SPFx folder serve as templats for all customisable assets. The names are not allowed to be changed because otherwise the whole deployment breaks. To make sure the template gets deployed a small utility need to called directly in the installation method of the Yeoman generator. Make sure you reference the utility class in your Yeoman generator code. // importing utilities const util = require ( ../../lib/util.js ); In the install method call the following utility method. install () { // # BUG currently only appears just in test util . writeTemplates ( this ); } This utility will detect which component got added during the regular SPFx runtime and adds the code directly to the file.","title":"Update provisioned artifacts for web parts, extensions and customizer with generator"},{"location":"recipes/deploy-custom-code/#update-provisioned-artifacts-for-web-parts-extensions-and-customizer-with-generator","text":"It is possible to inject code such as references directly web parts and extensions. Right now this is only supported for SharePoint Online projects and not for on-premises focused. The tools folder provide you templates to inject code directly in the web part, application customizer, command set, field customizer. tools/spfx \u251c\u2500\u2500 applicationcustomizer-spo \u2502 \u2514\u2500\u2500 { componentClassName } .ts \u251c\u2500\u2500 commandset-spo \u2502 \u2514\u2500\u2500 { componentClassName } .ts \u251c\u2500\u2500 fieldcustomizer-spo \u2502 \u251c\u2500\u2500 { componentClassName } .module.scss \u2502 \u2514\u2500\u2500 { componentClassName } .ts \u2514\u2500\u2500 webparts-spo \u251c\u2500\u2500 { componentClassName } .module.scss \u2514\u2500\u2500 { componentClassName } .ts These files will be maintained and updated with every new mayor release of the SharePoint Framework main generator.","title":"Update provisioned artifacts for web parts, extensions and customizer with generator"},{"location":"recipes/deploy-custom-code/#copy-these-template-files-to-your-generator","text":"Copy the files located in the template folder to your custom generator in the template path. The overall setup of the generator should match the following pattern. generators/your-generator/ \u251c\u2500\u2500 index.js \u2514\u2500\u2500 templates \u251c\u2500\u2500 addonConfig.json \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 copy-static-assets.json \u251c\u2500\u2500 gulpfile.js \u2514\u2500\u2500 spfx \u251c\u2500\u2500 applicationcustomizer-spo \u2502 \u2514\u2500\u2500 { componentClassName } .ts \u251c\u2500\u2500 fieldcustomizer-spo \u2502 \u251c\u2500\u2500 { componentClassName } .module.scss \u2502 \u2514\u2500\u2500 { componentClassName } .ts \u251c\u2500\u2500 listviewcommandset-spo \u2502 \u2514\u2500\u2500 { componentClassName } .ts \u2514\u2500\u2500 webpart-spo \u251c\u2500\u2500 { componentClassName } .module.scss \u2514\u2500\u2500 { componentClassName } .ts Now modify the files to match your requirements. In case of the HandlebarsJS generator the following line of code were added at the import statements of for example an web part. import { Version } from @microsoft/sp-core-library ; import { BaseClientSideWebPart , IPropertyPaneConfiguration , PropertyPaneTextField } from @microsoft/sp-webpart-base ; import { escape } from @microsoft/sp-lodash-subset ; import styles from ./ %= componentClassName % .module.scss ; import * as strings from %= componentStrings % ; import * as Handlebars from handlebars ; export interface I %= componentClassName % Props { description : string ; } export default class %= componentClassName % extends BaseClientSideWebPart I %= componentClassName % Props { ... The only line of code in this example that were added is the following line: import * as Handlebars from handlebars ; This make sure that after the provisioning of a web part coding can start immediatly.","title":"Copy these template files to your generator"},{"location":"recipes/deploy-custom-code/#deploy-custom-code-in-generator","text":"The files located in the SPFx folder serve as templats for all customisable assets. The names are not allowed to be changed because otherwise the whole deployment breaks. To make sure the template gets deployed a small utility need to called directly in the installation method of the Yeoman generator. Make sure you reference the utility class in your Yeoman generator code. // importing utilities const util = require ( ../../lib/util.js ); In the install method call the following utility method. install () { // # BUG currently only appears just in test util . writeTemplates ( this ); } This utility will detect which component got added during the regular SPFx runtime and adds the code directly to the file.","title":"Deploy custom code in generator"},{"location":"recipes/inject-gulp-tasks/","text":"Inject custom gulp task To inject a custom gulp task into a SharePoint Framework generated gulpfile.js , use the following method. Add a file named gulpfile.js in the templates folder of the custom generator. The following code sample shows the content taken from the Handlebars generator and registers the web pack loader along with a custom gulp watch: const loaderConfig = { test : /\\.hbs/ , loader : handlebars-template-loader }; // Merge custom loader to web pack configuration build . configureWebpack . mergeConfig ({ additionalConfiguration : ( generatedConfiguration ) = { generatedConfiguration . module . rules . push ( loaderConfig ); return generatedConfiguration ; } }); // Register watches sub task to move hbs files over to libs directory let hbsWatch = build . subTask ( hbsWatch , ( gulp , buildOptions , done ) = { gulp . watch ( ./**/*.hbs , () = { gulp . src ( ./src/**/*.hbs ) . pipe ( gulp . dest ( ./lib/ )); }); done (); }); build . rig . addPreBuildTask ( hbsWatch ); This file should only contain the required code that needs added to the SPFx owned gulpfile.js . Add the following code index.js after the end() method: _injectToGulpFile () { if ( fs . existsSync ( this . destinationPath ( gulpfile.js ))) { let coreGulpTemplate = this . templatePath ( ../../../app/templates/gulpfile.js ); let customGulpTemplate = this . templatePath ( ./gulpfile.js ) let mergedGulpFile = util . composeGulpFile ( coreGulpTemplate , customGulpTemplate ); fs . writeFileSync ( this . destinationPath ( ./gulpfile.js ), mergedGulpFile , utf-8 ); } } To execute the injection of your custom task in gulpfile.js , call this method from the install() method: install () { this . _injectToGulpFile (); } To verify, execute the yeoman generator and look up the changes within gulpfile.js in the project directory.","title":"Inject custom gulp task"},{"location":"recipes/inject-gulp-tasks/#inject-custom-gulp-task","text":"To inject a custom gulp task into a SharePoint Framework generated gulpfile.js , use the following method. Add a file named gulpfile.js in the templates folder of the custom generator. The following code sample shows the content taken from the Handlebars generator and registers the web pack loader along with a custom gulp watch: const loaderConfig = { test : /\\.hbs/ , loader : handlebars-template-loader }; // Merge custom loader to web pack configuration build . configureWebpack . mergeConfig ({ additionalConfiguration : ( generatedConfiguration ) = { generatedConfiguration . module . rules . push ( loaderConfig ); return generatedConfiguration ; } }); // Register watches sub task to move hbs files over to libs directory let hbsWatch = build . subTask ( hbsWatch , ( gulp , buildOptions , done ) = { gulp . watch ( ./**/*.hbs , () = { gulp . src ( ./src/**/*.hbs ) . pipe ( gulp . dest ( ./lib/ )); }); done (); }); build . rig . addPreBuildTask ( hbsWatch ); This file should only contain the required code that needs added to the SPFx owned gulpfile.js . Add the following code index.js after the end() method: _injectToGulpFile () { if ( fs . existsSync ( this . destinationPath ( gulpfile.js ))) { let coreGulpTemplate = this . templatePath ( ../../../app/templates/gulpfile.js ); let customGulpTemplate = this . templatePath ( ./gulpfile.js ) let mergedGulpFile = util . composeGulpFile ( coreGulpTemplate , customGulpTemplate ); fs . writeFileSync ( this . destinationPath ( ./gulpfile.js ), mergedGulpFile , utf-8 ); } } To execute the injection of your custom task in gulpfile.js , call this method from the install() method: install () { this . _injectToGulpFile (); } To verify, execute the yeoman generator and look up the changes within gulpfile.js in the project directory.","title":"Inject custom gulp task"},{"location":"recipes/run-install/","text":"Run install npm packages from generator After all required modifications have been applied to a new project by the Yeoman generator, the npm packages need to be installed. To provide a consistent method for all generators, a utility class was implemented that provides a single method to run the installer. Default behaviour of the installer Like the SPFx Default Yeoman generator installer, it supports the following three package managers: npm pnpm yarn Be default, the npm package manager will be used. If the yarn package manager is installed on the client, this package manager will instead be used by default. The pnpm package manager is available via a command line switch when the yeoman generator gets launched. To install dependencies with a specific package manager, the following options exist: To explicitly use npm: yo @pnp/spfx --pm npm or yo @pnp/spfx --package-manager npm To explicitly use pnpm: yo @pnp/spfx --pm pnpm or yo @pnp/spfx --package-manager pnpm To explicitly use pnpm: yo @pnp/spfx --pm yarn or yo @pnp/spfx --package-manager yarn Reference to the Util Your generators index.js should include the following line of code somewhere at the start: // importing utilities const util = require ( ../../lib/util.js ); Call npm package installation Add the following line of code in the install method of your generator: install (){ /* Custom configuration code should be placed before the installer */ util . runInstall ( this ); }","title":"Run install npm packages from generator"},{"location":"recipes/run-install/#run-install-npm-packages-from-generator","text":"After all required modifications have been applied to a new project by the Yeoman generator, the npm packages need to be installed. To provide a consistent method for all generators, a utility class was implemented that provides a single method to run the installer.","title":"Run install npm packages from generator"},{"location":"recipes/run-install/#default-behaviour-of-the-installer","text":"Like the SPFx Default Yeoman generator installer, it supports the following three package managers: npm pnpm yarn Be default, the npm package manager will be used. If the yarn package manager is installed on the client, this package manager will instead be used by default. The pnpm package manager is available via a command line switch when the yeoman generator gets launched. To install dependencies with a specific package manager, the following options exist: To explicitly use npm: yo @pnp/spfx --pm npm or yo @pnp/spfx --package-manager npm To explicitly use pnpm: yo @pnp/spfx --pm pnpm or yo @pnp/spfx --package-manager pnpm To explicitly use pnpm: yo @pnp/spfx --pm yarn or yo @pnp/spfx --package-manager yarn","title":"Default behaviour of the installer"},{"location":"recipes/run-install/#reference-to-the-util","text":"Your generators index.js should include the following line of code somewhere at the start: // importing utilities const util = require ( ../../lib/util.js );","title":"Reference to the Util"},{"location":"recipes/run-install/#call-npm-package-installation","text":"Add the following line of code in the install method of your generator: install (){ /* Custom configuration code should be placed before the installer */ util . runInstall ( this ); }","title":"Call npm package installation"},{"location":"tools/util/","text":"Util - Overview The util module can be found in the './lib/' directory and contains the following methods. mergeAddons(addonConfig, requestedLibraries, config) This method merges add-ons in package.json . addonConfig Configuration of add-ons available in the generator. requestedLibraries Array of requested library identifiers. config Given configuration to merge add-ons in the currently used package.json , for example. composeGulpFile(coreTemplate, customTemplate) This method allows you to inject custom gulp tasks in the gulp file. coreTemplate Path to any gulp file you would like to use as a template. customTemplate Contains all your custom gulp tasks you would like to inject. The core template in the generator provided by SPFx is located in the folder /app/templates/gulpfile.js and contains the following EJS code: use strict ; const gulp = require ( gulp ); const build = require ( @microsoft/sp-build-web ); build . addSuppression ( `Warning - [sass] The local CSS class ms-Grid is not camelCase and will not be type-safe.` ); %= customTasks % build . initialize ( gulp ); The custom generator can point to this file using the following code: let coreGulpTemplate = this . templatePath ( ../../../app/templates/gulpfile.js ); The following example shows a simple custom code snippet that should be included in the gulp file: // code to inject in gulp file console . log ( Hello PnP SPFx generator ); The resulting gulpfile.js after the merge in this case will be: use strict ; const gulp = require ( gulp ); const build = require ( @microsoft/sp-build-web ); build . addSuppression ( `Warning - [sass] The local CSS class ms-Grid is not camelCase and will not be type-safe.` ); // code to inject in gulp file console . log ( Hello PnP SPFx generator ); build . initialize ( gulp );","title":"Util - Overview"},{"location":"tools/util/#util-overview","text":"The util module can be found in the './lib/' directory and contains the following methods.","title":"Util - Overview"},{"location":"tools/util/#mergeaddonsaddonconfig-requestedlibraries-config","text":"This method merges add-ons in package.json . addonConfig Configuration of add-ons available in the generator. requestedLibraries Array of requested library identifiers. config Given configuration to merge add-ons in the currently used package.json , for example.","title":"mergeAddons(addonConfig, requestedLibraries, config)"},{"location":"tools/util/#composegulpfilecoretemplate-customtemplate","text":"This method allows you to inject custom gulp tasks in the gulp file. coreTemplate Path to any gulp file you would like to use as a template. customTemplate Contains all your custom gulp tasks you would like to inject. The core template in the generator provided by SPFx is located in the folder /app/templates/gulpfile.js and contains the following EJS code: use strict ; const gulp = require ( gulp ); const build = require ( @microsoft/sp-build-web ); build . addSuppression ( `Warning - [sass] The local CSS class ms-Grid is not camelCase and will not be type-safe.` ); %= customTasks % build . initialize ( gulp ); The custom generator can point to this file using the following code: let coreGulpTemplate = this . templatePath ( ../../../app/templates/gulpfile.js ); The following example shows a simple custom code snippet that should be included in the gulp file: // code to inject in gulp file console . log ( Hello PnP SPFx generator ); The resulting gulpfile.js after the merge in this case will be: use strict ; const gulp = require ( gulp ); const build = require ( @microsoft/sp-build-web ); build . addSuppression ( `Warning - [sass] The local CSS class ms-Grid is not camelCase and will not be type-safe.` ); // code to inject in gulp file console . log ( Hello PnP SPFx generator ); build . initialize ( gulp );","title":"composeGulpFile(coreTemplate, customTemplate)"}]}